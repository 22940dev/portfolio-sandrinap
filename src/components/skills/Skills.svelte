<script>
  import { onMount, afterUpdate } from 'svelte';
  import SkillsList from './SkillsList.svelte';
  import { getInLimit, scrollIntoView } from '../../utils';
  import { _window, matchMq, afterResponsiveUpdate } from '../../stores/responsive.js';
  import { strGeneral, updateGeneral, afterGeneralUpdate } from '../../stores/general.js';
  import { GITHUB_URL, CODEPEN_URL, SITE_REPO } from '../../data/misc.js';

  $: wHeight = $_window && $_window.innerHeight;

  let elTitle;

  let isVisible = false;
  let isOnStage = false;
  let animation;
  let progressN = 0; // title scale
  let progressY = 0; // title translate
  let colorType = null;

  afterGeneralUpdate((prevState, state) => {
    const prevPageSection = prevState.pageCurrentSection;
    const pageSection = state.pageCurrentSection;

    if (!prevState.isReady && state.isReady) {
      animation = initAnimation();
    }

    if (prevPageSection !== pageSection && pageSection === 'skills') {
      animation.verify();
    }
  });

  afterResponsiveUpdate(() => {
    if(!animation) { return }
    animation && animation.verify();
    console.warn('Resize: skills updated');
  })


  function initAnimation() {
    let startAt; // where animation starts
    let endsAt; // where it ends
    let range; // the space where "zoom magic" happens
    /*
      +--------------------+ 
      |                    | [2]+
      |                    |    |
      |      VIEWPORT      |    |-[3]
      |                    |    |
      |                    | [1]+
      +--------------------+
    */

    function handleScroll() {
      console.log('scrolling skills...');
      const scrollY = window.scrollY;
      const fromStart = scrollY - startAt;
      progressN = getInLimit(fromStart/range, 0, 1);
      progressY = `${(range - progressN*range/1) * -1}px`
      isVisible = progressN === 1;
    }

    const watchTitle = ([{ isIntersecting, boundingClientRect }]) => {
      const topScreen = window.scrollY + $_window.innerHeight - ($_window.innerHeight - boundingClientRect.top);
      startAt = topScreen - wHeight / 1.5;
      endsAt = topScreen - wHeight / 4; // 25vh - same as $paddingTop
      range = endsAt - startAt;

      if (isIntersecting) {
        handleScroll()
        window.addEventListener('scroll', handleScroll, { passive: true });
      } else {
        window.removeEventListener('scroll', handleScroll);
      }
    };

    const observer = new IntersectionObserver(watchTitle);

    observer.observe(elTitle); // OPTIMIZE - disconnect

    return {
      verify: () => {
        const boundingClientRect = elTitle.getBoundingClientRect();
        watchTitle([{
          isIntersecting: boundingClientRect.top < wHeight,
          boundingClientRect,
        }])
      }
    }
  }

  function handleColorType(ev) {
    colorType = ev.detail.colorType
  }

  function handleKeyboardFocus(e) {
    if(isVisible) { return }

    scrollIntoView(e, {
      value: $_window.innerHeight * -0.25 // same as css $paddingTop.
    })
    
    animation.verify();
  }
</script>

<style>
  .wrapper {
    --skills-bg: var(--bg_invert);
    position: relative;
    min-height: 100vh;
    overflow: hidden;
    padding-top: 50vw;
    padding-bottom: 4rem;
    background-color: var(--bg_0);
    transition: background-color 400ms cubic-bezier(0.19, 1, 0.22, 1);

    &::before { /* smooth transition between sections borders, in case we scroll too fast. */
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 8rem;
      display: block;
      background: linear-gradient(var(--bg_0) 2px, var(--skills-bg));
      opacity: 0;
      transition: opacity 400ms cubic-bezier(0.19, 1, 0.22, 1);
    }

    :global(.dark) & {
      --skills-bg: var(--bg_1);
    }

    &.uAppear {
      background-color: #1b1b1b; /* var(--bg_invert) - fallback css variables */
      background-color: var(--skills-bg);

      &::before {
        opacity: 1;
      }
    }
    /* 
    @media (--md) {
      padding-bottom: 10vh; -- no need, too big on taller screens
    } */
  }

  .header {
    position: relative;
    margin-top: $spacer-L;
    display: flex;
    flex-direction: column;
    align-items: center;
    
    &Title {
      position: relative;
      font-size: calc($font-heading_1 * 0.8);
      color: transparent;
      transform-origin: 50% 0%;
      -webkit-text-stroke: 0.1rem var(--text_1);
      opacity: var(--progressN, 0);
      transform:
        scale(var(--progressN, 1))
        translateY(var(--progressY, 0));
      transition: transform 100ms ease,
        text-shadow 150ms; 

      .uAppear & {
        -webkit-text-stroke: initial;
        color: var(--text_invert);

        :global(.dark) & {
          color: var(--text_0);
        }
      }
    }

    &Desc {
      padding: $spacer-S $layout-margin;
      color: var(--text_invert);

      :global(.dark) & {
        color: var(--text_0);
      }
    }
  }

  @media (--md) {
    $paddingTop: 25vh; /* enough to cover all in black I guess */

    .wrapper {
      padding-top: $paddingTop;
      min-height: 100vh;
    }

    .header {
      &Title {
        font-size: $font-heading_0;

        .uAppear & {
          /* TIL: fake opacity without opacity */
          text-shadow:
            0 0 4.5rem var(--skills-bg),
            0 0 4.5rem var(--skills-bg),
            0 0 3.5rem var(--colorTabSelected);
        }
      }

      &Desc {
        padding: 0;
      }
    }
  }
</style>

<section
  class="wrapper"
  class:uAppear={isVisible}
  class:uAppearSoon={!isVisible}
  id="skills"
  on:focusin={handleKeyboardFocus}
  data-section-offset-h="5">

  <header class="header"
    style="--colorTabSelected: {colorType};"
    bind:this={elTitle}>
    <h2 class="headerTitle f-mono"
      style='--progressN: {progressN}; --progressY: {progressY}'>
      skills
    </h2>
    <p class="headerDesc uAppear-0">
      Take a sneak peek on <a href={GITHUB_URL} class="u-link">Github</a> and <a href={CODEPEN_URL} class="u-link">Codepen</a>
    </p>
  </header>
  
  <SkillsList on:setColorType={handleColorType} />
</section>
